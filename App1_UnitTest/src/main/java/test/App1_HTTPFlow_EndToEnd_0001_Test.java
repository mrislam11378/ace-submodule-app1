package test;

import org.hamcrest.Matchers;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.Test;

import com.ibm.integration.test.v1.NodeSpy;
import com.ibm.integration.test.v1.SpyObjectReference;
import com.ibm.integration.test.v1.TestMessageAssembly;
import com.ibm.integration.test.v1.TestSetup;
import com.ibm.integration.test.v1.exception.TestException;

import static com.ibm.integration.test.v1.Matchers.*;
import static org.hamcrest.MatcherAssert.assertThat;

public class App1_HTTPFlow_EndToEnd_0001_Test {

	/*
	 * App1_HTTPFlow_Compute_0001_Test
	 * Test generated by IBM App Connect Enterprise Toolkit 12.0.8.0 on Mar 30, 2023 4:10:34 PM
	 */

	@AfterEach
	public void cleanupTest() throws TestException {
		// Ensure any mocks created by a test are cleared after the test runs 
		TestSetup.restoreAllMocks();
	}

	@Test
	public void App1_HTTPFlow_TestCase_001() throws TestException {

		// Define the SpyObjectReference objects
		SpyObjectReference httpInputObjRef = new SpyObjectReference().application("App1")
				.messageFlow("HTTPFlow").node("HTTP Input");
		SpyObjectReference httpReplyObjRef = new SpyObjectReference().application("App1")
				.messageFlow("HTTPFlow").node("HTTP Reply");

		// Initialise NodeSpy objects
		NodeSpy httpInputSpy = new NodeSpy(httpInputObjRef);
		NodeSpy httpReplySpy = new NodeSpy(httpReplyObjRef);
		
		// Declare a new TestMessageAssembly object for the message being sent into the node
		TestMessageAssembly inputMessageAssembly = new TestMessageAssembly();
		

		// Configure the "in" terminal on the HTTP Reply node not to propagate.
		// If we don't do this, then the reply node will throw exceptions when it  
		// realises we haven't actually used the HTTP transport.
		httpReplySpy.setStopAtInputTerminal("in");

		// Now call propagate on the "out" terminal of the HTTP Input node.
		// This takes the place of an actual HTTP message: we simple hand the node
		// the message assembly and tell it to propagate that as if it came from an
		// actual client. This line is where the flow is actually run.
		httpInputSpy.propagate(inputMessageAssembly, "out");
		
		// Validate the results from the flow execution
        // We will now pick up the message that is propagated into the "HttpReply" node and validate it
		TestMessageAssembly replyMessageAssembly = httpReplySpy.receivedMessageAssembly("in", 1);
		

        /* Not trying to check too much detail - lots more tests needed! */
        assertThat(replyMessageAssembly, hasMessageTreeElement("HTTPReplyHeader.DemoHeader"));
	}

}
